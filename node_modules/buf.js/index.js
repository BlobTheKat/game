let txt = new TextEncoder()
let txtd = new TextDecoder()
let F = a => typeof a == "string"

class BufWriter{
  constructor(){
    this.buf = [new Uint8Array(256)]
    this.i = 0
    this.si = this.buf[0]
    this.e = 0
    this.se = this.buf[0]
    this.se = null
  }
  nib(nib){
    if(this.se){
      this.se[this.e] |= nib << 4
      this.se = null
    }else{
      (this.se = this.buf[this.buf.length - 1])[this.e = this.i++] = nib
      if(this.i === 256)this.i = 0, this.buf.push(this.si = new Uint8Array(256))
    }
  }
  byte(byte){
    this.si[this.i++] = byte
    if(this.i == 256)this.i = 0, this.buf.push(this.si = new Uint8Array(256))
  }
  short(short){
    this.si[this.i++] = short
    if(this.i > 254){
      if(this.i === 256){
        this.i = 1
        this.buf.push(this.si = new Uint8Array(256))
        this.si[0] = short >> 8
      }else{
        this.i = 0
        this.si[255] = short >> 8
        this.buf.push(this.si = new Uint8Array(256))
      }
    }else{
        this.si[this.i++] = short >> 8
    }
  }
  int(int){
    this.si[this.i++] = int
    if(this.i > 252){
      if(this.i === 256){
        this.i = 3
        this.buf.push(this.si = new Uint8Array(256))
        this.si[0] = int >> 8
        this.si[1] = int >> 16
        this.si[2] = int >> 24
      }else if(this.i === 255){
        this.i = 2
        this.si[255] = int >> 8
        this.buf.push(this.si = new Uint8Array(256))
        this.si[0] = int >> 16
        this.si[1] = int >> 24
      }else if(this.i === 254){
        this.i = 1
        this.si[254] = int >> 8
        this.si[255] = int >> 16
        this.buf.push(this.si = new Uint8Array(256))
        this.si[0] = int >> 24
      }else{
        this.i = 0
        this.si[253] = int >> 8
        this.si[254] = int >> 16
        this.si[255] = int >> 24
        this.buf.push(this.si = new Uint8Array(256))
      }
    }else{
      this.si[this.i++] = int >> 8
      this.si[this.i++] = int >> 16
      this.si[this.i++] = int >> 24
    }
  }
  float(float){
    let int = new Int32Array(new Float32Array([float]).buffer)[0]
    this.int(int)
  }
  double(double){
    let [a, b] = new Int32Array(new Float64Array([double]).buffer)
    this.int(a)
    this.int(b)
  }
  flint(flex){
    if(flex < 128){
      this.si[this.i++] = flex
      if(this.i === 256)this.i = 0, this.buf.push(this.si = new Uint8Array(256))
    }else{
      this.int(128 + (flex & 127) + ((flex & 2147483520) << 1))
    }
  }
  buffer(buf){
    let l = 256 - this.i
    if(buf.length < l){
      this.si.set(buf, this.i)
      this.i += buf.length
    }else if(buf.length == l){
      this.si.set(buf, this.i)
      this.i = 0
      this.buf.push(this.si = new Uint8Array(256))
    }else{
      this.si.set(buf.subarray(0, l), this.i)
      while(l <= buf.length - 256)this.buf.push(buf.subarray(l, l += 256))
      this.buf.push(this.si = new Uint8Array(256))
      this.si.set(buf.subarray(l), 0)
      this.i = buf.length - l
    }
  }
  str(str){
    let buf = txt.encode(str)
    this.flint(buf.length)
    this.buffer(buf)
  }
  obj(obj, val){
    if(obj < 0){
      if(obj === -15){
        if(val == null){
          this.byte(127)
        }else if(val < 127){
          this.byte(val)
        }else{
          this.int(128 + (val & 127) + ((val & 2147483520) << 1))
        }
        return
      }else if(obj === -10){
        if(val == null){
          this.byte(127)
          return
        }else if((val+="").length < 127){
          let buf = txt.encode(val)
          this.byte(buf.length)
          this.buffer(buf)
        }else{
          let buf = txt.encode(val)
          this.int(128 + (buf.length & 127) + ((buf.length & 2147483520) << 1))
          this.buffer(buf)
        }
        
        return
      }
      if(val == null){
        this.nib(15)
        return
      }
      if(obj === -11){
        this.nib(!!val)
        return
      }
      this.nib(0)
      obj = ~obj
    }
    switch(obj){
      case 0:
      this.nib(val)
      return
      case 1:
      case 2:
      this.byte(val)
      return
      case 3:
      case 4:
      this.short(val)
      return
      case 5:
      case 6:
      this.int(val)
      return
      case 7:
      this.float(val)
      return
      case 8:
      this.double(val)
      return
      case 9:
      val += ""
      let buf = txt.encode(val)
      this.flint(buf.length)
      this.buffer(buf)
      return
      case 10:
      this.nib(!!val)
      return
      //11, 12 and 13 don't have variables attached
      case 14:
      this.flint(val)
      return
      case 15:
      switch(typeof val){
        case "number":
        if(val === val << 0){
          if(val === (val & 15))return void(this.nib(0), this.nib(val))
          let i = Math.ceil(Math.clz32(val < 0 ? ~val : val) / 8)
          if(i == 4)return void(this.nib(1), this.byte(val))
          else if(i == 3)return void(this.nib(3), this.short(val))
          else return void(this.nib(5), this.int(val))
        }else{
          if(new Float32Array([val]) == val)return void(this.nib(7), this.float(val))
          else return void(this.nib(8), this.double(val))
        }
        case "string":
        this.nib(9)
        let buf = txt.encode(val)
        this.flint(buf.length)
        this.buffer(buf)
        return
        case "boolean":
        this.nib(val ? 15 : 10)
        return
        case "object":
        if(!val)return void this.nib(11)
        if(Array.isArray(val)){
          this.nib(12)
          this.flint(val.length)
          for(var i of val){
            this.obj(15, i)
          }
          return
        }else{
          this.nib(13)
          let keys = Object.keys(val).filter(F)
          this.flint(keys.length)
          for(var i of keys){
            let buf = txt.encode(i)
            this.flint(buf.length)
            this.buffer(buf)
            this.obj(15, val[i])
          }
          return
        }
        default:
        this.nib(11)
      }
      default:
      if(Array.isArray(obj)){
        let o1 = obj[1] == null ? (this.flint(val.length),val.length) : obj[1]
        let arr = val.slice(0,o1)
        arr.length = o1
        for(let i of arr){
          this.obj(obj[0], i)
        }
        return
      }else if(obj && typeof obj == "object"){
        for(let i in obj){
          this.obj(obj[i], val[i])
        }
        return
      }
    }
  }
  toBuf(){
    let a = this.buf.slice(0, -1)
    let buf = new Uint8Array(a.length * 256 + this.i)
    a.push(this.si.subarray(0, this.i))
    for(var i in a){
      buf.set(a[i], i * 256)
    }
    return new Buf(buf.buffer)
  }
}
class Buf extends Uint8Array{
  constructor(a){
    super(a)
    this.i = 0
    this.si = -1
  }
  nib(){
    if(this.si > -1){
      let i = this[this.si] >> 4
      this.si = -1
      return i
    }else{
      this.si = this.i
      this.i++
      return this[this.si] & 15
    }
  }
  ubyte(){
    return this[this.i++]|0
  }
  byte(){
    return this[this.i++] << 24 >> 24
  }
  short(){
    return ((this[this.i++]|0) + (this[this.i++] << 8)) << 16 >> 16
  }
  ushort(){
    return (this[this.i++]|0) + (this[this.i++] << 8)
  }
  int(){
    return (this[this.i++]|0) + (this[this.i++] << 8) + (this[this.i++] << 16) + (this[this.i++] << 24)
  }
  uint(){
    return (this[this.i++]|0) + (this[this.i++] << 8) + (this[this.i++] << 16) + (this[this.i++] << 24 >>> 0)
  }
  float(){
    return new Float32Array(new Uint8Array([this[this.i++], this[this.i++], this[this.i++], this[this.i++]]).buffer)[0]
  }
  double(){
    return new Float64Array(new Uint8Array([this[this.i++], this[this.i++], this[this.i++], this[this.i++], this[this.i++], this[this.i++], this[this.i++], this[this.i++]]).buffer)[0]
  }
  flint(){
    let a = this[this.i++]|0
    if(a > 127)a -= 128
    else return a
    a += this[this.i++] << 7
    a += this[this.i++] << 15
    a += this[this.i++] << 23
    return a
  }
  buffer(len){
    return new Uint8Array(super.buffer).subarray(this.i, this.i += len)
  }
  str(len = this.flint()){
    return txtd.decode(new Uint8Array(this).subarray(this.i, this.i += len))
  }
  obj(obj){
    if(obj < 0){
      if(obj === -15){
        return this[this.i] === 127 ? (this.i++,null) : this.flint()
      }else if(obj === -10){
        return this[this.i] === 127 ? (this.i++,null) : this.str()
      }
      let a = this.nib()
      if(a === 15)return null
      if(obj === -11){
        return a != 0
      }
      obj = ~obj
    }
    switch(obj){
      case 0:
      return this.nib()
      case 1:
      return this.byte()
      case 2:
      return this.ubyte()
      case 3:
      return this.short()
      case 4:
      return this.ushort()
      case 5:
      return this.int()
      case 6:
      return this.uint()
      case 7:
      return this.float()
      case 8:
      return this.double()
      case 9:
      let len = this.flint()
      return txtd.decode(new Uint8Array(this).subarray(this.i, this.i += len))
      case 10:
      return this.nib() != 0
      //11, 12 and 13 don't have variables attached
      case 14:
      return this.flint()
      case 15:
      let type = this.nib()
      if(type == 11)return null
      if(type == 15)return true
      if(type == 10)return false
      if(type == 12){
        let length = this.flint()
        let a = Array.from({length})
        let i = -1
        while(++i < length){
          a[i] = this.obj(15)
        }
        return a
      }
      if(type == 13){
        let len = this.flint()
        let a = Object.create(null)
        while(len--){
          let l = this.flint()
          a[txtd.decode(new Uint8Array(this).subarray(this.i, this.i += l))] = this.obj(15)
        }
        return a
      }
      return this.obj(type)
      default:
      if(Array.isArray(obj)){
        let length = obj[1] == null ? this.flint() : obj[1]
        let arr = Array.from({length})
        let i = -1
        while(++i < length){
          arr[i] = this.obj(obj[0])
        }
        return arr
      }else if(obj && typeof obj == "object"){
        let ob = Object.create(null)
        for(let i in obj){
          ob[i] = this.obj(obj[i])
        }
        return ob
      }
      return null
    }
  }
}

module.exports = {Buf, BufWriter, TYPES: {
	NIBBLE: 0,
  BYTE: 1,
  UBYTE: 2,
  SHORT: 3,
  USHORT: 4,
  INT: 5,
  UINT: 6,
  FLOAT: 7,
  DOUBLE: 8,
  STRING: 9,
  BOOL: 10,
  OPT: a => a < 0 ? a : ~a, //11, stored it actually signifies null
  //12 => arr
  //13 => obj
  FLEXINT: 14,
  ANY: 15
}}
